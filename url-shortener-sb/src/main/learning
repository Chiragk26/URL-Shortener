1. @Data-> getter, setter, required args constructor( creates constructor for only final and Nonnull fields),<equals(), hashcode()>, toString()
2. Relationships have 2 sides-> a owner side(has a foreign key and use JoinColumn) and inverse side( just points the owner ,it uses mappedBy)
3. Flow-:
JwtAuthenticationFilter: Intercepts http requests and extracts JWT tokens.
JwtUtils: tool that generates, reads and validates tokens. Used by JwtAuthenticationFilter.
UserDetailsServiceImpl: Fetch user details from the database.
UserDetailsImpl: provides spring security compatible representation for custom users. its the return type of UserDetailsServiceImpl.
4.Configuring Spring Security: We have User entity and spring security user(UserDetails interface--> UserDetailsImpl). Spring Security needs to know user entity inorder to validate it.
So in UserDetailsImpl we define the required fields and methods with a build method that converts user entity to userDetailsImpl.
5.Optional: a container object that may or may not contain a non-null value. It never contains a null value.
we can use Optional.ofNullable(value)--> returns value wrapped in Optional container/empty optional container
or return value
       .orElseThrow(()->new exceptionname("");--> this would return value or an exception when null
when Optional.of(value)--> returns value wrapped in optional container/ simply null that can result in null pointer exception
so, optional doesnt magically handles null pointer exception, it can when used correctly
6.


7. Security Config:
Define security rules for handling http requests.
Configure JwtAuthenticationFilter in filter chain->Spring security recognizes JwtAuthenticationFilter as a filter that will be executed once per request,but doesn't automatically include in filter chain unless explicity added.
Configure DaoAuthenticationFilter-> needed for the custom user we are loading in userDetailsService
Bean for AuthenticationManager and PasswordEncoder.


